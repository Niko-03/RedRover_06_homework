''' ------------ЛИСТЫ, КОРТЕЖИ, СЛОВАРИ, МНОЖЕСТВА ----------------

-------- Список (list): -----------------------------------------------------------------------
- тип данных, который хранит набор или последовательность элементов
- может хранить разные типы данных, в том числе и другие списки (вложенные)
- изменяемая структура данных
- my_list = []  -  создание списка с помощью []
- my_list = list()  -  создание списка при помощи функции

Генерация списков (LIST COMPREHENSION):
- позволяет использовать сокращенный синтаксис при создании нового списка на основе значений уже существующего списка
- NEWLIST = [EXPRESSION FOR ITEM IN ITERABLE IF CONDITION == TRUE]

     For loop                                List Comprehension
lis = [1, 2, 3, 4, 5]                     lis = [1, 2, 3, 4, 5]
new_lis = []                              new_lis = [x*x for x in lis if x%2]
for x in lis:                             print(new_lis)
    if x%2:
        new_lis.append(x*x)
print(new_lis)

----------- Кортеж (tuple): ---------------------------------------------------------------
- неизменяемая структура данных, используют в случаях, когда важно соблюсти целостность данных
- может хранить разные типы данных
- элементы внутри разделяются запятыми
- кортежи создаются с помощью:
        - круглых скобок:    MY_TUPLE = ()
        - функции TUPLE():   MY_TUPLE = TUPLE()
        - при перечислении нескольких значений через запятую: MY_TUPLE = 1, 2, 3

MY_TUPLE = (1, True, 'name', None, 2.3)

- с помощью кортежа моно передавать в функцию произвольное количество аргументов
    DEF FUNC(*ARGS)   -  символ * означает, что кортеж надо распаковать

def func(*args):
    for item in args:
        return item*item
print(func(2, 5, 6, 8, 10))

---------- Словарь (dictionary): -----------------------------------------------------------------
- изменяемая структура данных
- хранит коллекцию элементов, где каждый элемент имеет уникальный ключ и связанное с ним значение
- создаётся с помощью
    - фигурных скобок:      MY_DICT = {}
    - функции DICT:         MY_DICT = DICT()

DICTIONARY = {КЛЮЧ1:ЗНАЧЕНИЕ1, КЛЮЧ2:ЗНАЧЕНИЕ2, .....}

- КЛЮЧ - только str, int, float, и только уникальные значения
- ЗНАЧЕНИЕ - может быть любого типа

- обращение к элементу словаря по ключу  -   MY_DICT[КЛЮЧ]

-------------- Множество (set): -----------------------------------------------------------------
- похоже на словарь, в котором только ключи (должны быть уникальными)
- не упорядоченная структура данных
- удобно использовать для удаления повторяющихся элементов (убирает все дубликаты)
- создаётся при помощи:
    перечисления элементов в фиг.скобках         MY_SET = {'A', 'B', 'C'}
    функции SET{}                                MY_SET = SET{}

'''

# ------- про СПИСОК (LIST) ----------

# my_list = [1, 'hello', 2.0, 1, True, None]      # способ создания списка
#
# sentence = 'Python is awesome!'          # или так: есть строка
# print(sentence.split(' '))               # на выходе получим список
# print(sentence.split(' ', maxsplit=1))   # или так

# print(my_list[0])                                # получить элемент списка
# print(my_list[-1])                               # получить последний элемент списка
#
# print(f'Before: {my_list}, {id(my_list)}')
# my_list[0] = 12                                  # изменить значение элемента в списке
# print(f'After: {my_list}, {id(my_list)}')        # id не меняется, то есть список - изменяемый тип данных

# my_list.append(sentence)                          # добавление элемента в список
# my_list.append(125)
# print(my_list)
# print(len(my_list))                               # длина списка (количество элементов)
#
# my_list.insert(1, sentence)                       # добавление элемента в конкретное место в списке
# print(my_list)
#
# print(my_list.count(1))                           # количество вхождений элемента в список
# print(my_list.index(1))                            # узнать индекс элемента
# print(my_list.index(None))


# my_list1 = [1, 2, 3, 4, 5, 6, 7]
# print(my_list1)
# print(sum(my_list1))                        # сумма значений элементов списка (только для int и float)
# print(min(my_list1))                        # элемент списка с минимальным значением
# print(max(my_list1))                        # элемент списка с максимальным значением

# my_list2 = [1, 2, 3, 4, 5, 6, 7, [1, 2, 3, 4, 5]]     # вложенный список
# print(my_list2)
# print(my_list2[-1][1])                                # получить элемент из вложенного списка
# print(my_list1)
# print(my_list1)


# my_list3 = [1, 2, 3, 4, 5, 6, 7, [1, 2, 3, 4, 5, [7, 15, 4, 9]]]     # ещё одно вложение во вложенный список
# print(my_list3)
# print(my_list3[-1][-1][3])

# print(my_list)
# my_list.reverse()                    # получить элементы списка в обратном порядке
# print(my_list)

# numbers = [1, 2, 3, 4, 5]                     # for loop with list (для цикла со списком)
# for num in numbers:
#     print(num**2)                           # выведет элементы отдельно
#
# new_l = [i*i for i in numbers if i % 2 == 0]     # это выражение (i*i) примени для каждой переменной в нашем списке, если элемент в списке - четное число
# print(new_l)                                     # выведет элементы как список
#
# new_l = [i for i in numbers if i % 2 == 0]     # выведи элемент списка, если он - четное число
# print(new_l)

# --------- Генерация списков (LIST COMPREHENSION) -------------------------

#     For loop
# lis = [1, 2, 3, 4, 5]              # есть список
# new_lis = []                       # есть новый список
# for x in lis:                      # в цикле перебираем элементы списка lis (для x и списке lis...)
#     if x % 2:                      # если элемент нечётный (True),
#         new_lis.append(x*x)        # то возводим его в квадрат
# print(new_lis)                     # и выводим новый список

#   List Comprehension
# lis = [1, 2, 3, 4, 5]
# new_lis = [x * x for x in lis if x % 2]    # возведи в квадрат число из списка lis, если число нечётное (остаток от деления равен 1 - True)
# print(new_lis)


# ------- про КОРТЕЖ (TUPLE) -----------------------------------------

# my_tuple = 1, 2, 3          # вариант создания кортежа
# print(my_tuple)
# print(type(my_tuple))

# my_tuple1 = (1, True, 'name', None, 'name', 'name', 25)       # ещё вариант создания кортежа
# print(my_tuple1)
# print(my_tuple1.index('name'))        # вернёт индекс первого такого элемента, если их в кортеже несколько
# print(my_tuple1.count('name'))        # вернёт количество вхождений элемента

# my_tuple3 = 'Mark',         # создание кортежа с одним значением
# my_tuple4 = (15,)           #  или так
# print(my_tuple3)
# print(my_tuple4)

# my_tup = ('apple', 'banana', 'cat')
# print(my_tup)
# a, b, c = my_tup                 # декомпозиция кортежа (каждый элемент кортежа
# print(a)                      # присваивается какой-то переменной)
# print(b)
# print(c)

# my_tup[0] = 'ananas'     # будет ошибка \ для изменения элемента в кортеже необходимо перевести кортеж в list (список)
# letters = list(my_tup)     # из кортежа сделали список
# letters[0] = 'ananas'      # изменили элемент с индексом [0]
# print(letters)             # на выходе список
# new_tup = tuple(letters)   # из листа сделали кортеж
# print(new_tup)
# print(type(new_tup))

# my_tuple1 = (1, 'name', None, 'name', 'name', 25)
# result = tuple([item for item in my_tuple1 if isinstance(item, int)])  # верни элемент из my_tuple1, если его тип данных int
# print(result)                                                          # если не оборачивать в tuple, то на выходе будет список

# Методы tuple
# print(f'Sum is:{sum(result)}')
# print(f'Max is:{max(result)}')
# print(f'Min is:{min(result)}')
# print(f'Length of my_tuple1 is:{len(my_tuple1)}')
# print(f'Length of result is:{len(result)}')

# for (index, item) in enumerate(my_tuple1):          # цикл - получили пару (индекс, элемент) нашего кортежа
#     print(index, item)

# i = 0                                   # счётчик - 0
# while i < len(my_tuple1):               # цикл закончится, как только i станет меньше, чем количество элементов в кортеже
#     print(i, my_tuple1[i])                 # верни элемент кортежа
#     i += 1                              # переход к следующему элементу

# fruits = ('apple', 'banana', ['ananas', 'mango'], 'melon')
# fruits[2][0] = 'cherry'     # если внутри кортежа вложен список, то его можно менять
# print(fruits)               # на выходе кортеж с вложенным списком, как и было вначале

# swaping variables
# a = 5
# b = 10
# a, b = b, a              # изменение значений переменных
# print(f'a = {a}')
# print(f'b = {b}')


''' ================== ПРО ФУНКЦИИ =====================

def sum_it(*args):                       # в скобках - параметры функции, (*) означает, что принимаем произвольное количество аргументов   
print(sum_it(4, 5, 10, 6, 20, 35, 7))    # после вызова функции - в скобках - аргументы  

* - символ распаковки

def sum_it(num1):                 # такая запись значит, что функция принимает один параметр

'''

# def sum_it(*args):                     # функция sum_it принимает произвольное количество элементов (*args), мы хотим получить сумму всех переданных значений
#     total = 0                          # есть переменная total
#     print(args)                        # для наглядности
#     for num in args:                   # проходимся по нашему кортежу args - (4, 5, 10, 6, 20), по элементам
#         total = total + num            # к переменной total прибавляем значение элемента num нашего кортежа (4, 5, 10, 6, 20)
#     return total                       #
#
#
# print(sum_it(4, 5, 10, 6, 20, 35, 7))     # на выходе получим сумму элементов кортежа

# =====================================================================================================================
# def func(*args):
#     l = []                            # создали список
#     # print(len(args))                # можно без этой строки - это длина кортежа (*args), который задали в print`е
#     for item in args:                 # каждый элемент в кортеже...
#         l.append(item*item)           # ...возводим в квадрат
#     return l                          # возвращаем список l
#
#
# print(func(4, 5, 10, 6, 20, 35, 7))       # аргументы для нашей функции func

# ===============================================================================================================
# def sum_it(num1, num2, num3):  # параметры функции
#     sum = num1 + num2 + num3
#     return sum
#
#
# print(sum_it(5, 7, 3))         # аргументы функции
#
# #============================================================================================================
# def sum_it(num1, num2, num3):  # параметры функции
#     sum = num1 + num2 + num3
#     print(sum)
#
#
# sum_it(51, 17, 3)         # вызов функции с аргументами


# ------- про СЛОВАРЬ (DICTIONARY) -----------------------------------------
# my_dict = {}
# print(type(my_dict))

# my_dict = {
#     'name': 'Anna',
#     'last_name': 'Pavlova',
#     'age': 30,
#     'department': 'IT'
# }
# print(my_dict)
# # print(id(my_dict))
# print(my_dict['name'])
#
# my_dict['last_name'] = 'Smirnova'
# # print(my_dict)
# print(id(my_dict))

# print(len(my_dict))                    # вернёт количество пар (ключ:значение) - длина словаря

# my_dict['salary'] = 50000                 # добавление новой пары в словарь
# print(my_dict)

# print(my_dict.keys())                  # вернёт все ключи
# print(my_dict.values())                # вернёт все значения
# print(my_dict.items())                 # создаёт кортеж для каждой пары (ключ:значение)
#
# print(my_dict.pop('name'))             # удаляет ключ из словаря и возвращает его значение
# print(my_dict)
#
# print(my_dict.get('department'))             # получение значения по ключу
# print(my_dict.get('salary'))                 # вернёт None, если такого ключа нет
# print(my_dict.get('salary', 'Not found'))    # или так, для наглядности кастомное сообщение, если ключ не найден

# print(my_dict.clear())                           # очистить словарь
# print(my_dict.copy())                            # скопировать словарь
#
# print(min(my_dict))                      # получить ключ с минимальным значением
# print(max(my_dict))                      # получить ключ с максимальным значением

# --------- Создать словарь с помощью функции zip ----------

# keys = ['name', 'salary', 'department']         #  есть два списка
# values = ['Alex', 50000, 'HR']
# employee = dict(zip(keys, values))              # функция zip
# print(employee)

# employee1 = dict(name='John', position='developer', salary=70000, department='IT', city='NY')   # ещё один способ создания словаря
# print(employee1)


# ------- про МНОЖЕСТВО (SET) -----------------------------------------
# my_list = [1, 8, 2, 1, 5, 8, 9, 9, 7, 5, 8, 3]
# print(my_list)
# print(set(my_list))       # преобразовали список в множество, и повторяющиеся элементы пропали из множества

# set1 = {1, 2, 3, 'one', 'ten', 6}
# set2 = {1, 2, 3, 'one', 'ten', 100, 525}
# set3 = {1, 2, 3}

# print(set1.issubset(set2))                    # является ли set1 подмножеством set2 (True, если все значения set1 входят в set2)
# print(set2.issuperset(set1))                  # set2 является суперсетом для set1 (set2 включает в себя все значения set1)
# print(set2.intersection(set1))                # проверка на совпадения (одинаковые значения в set1 и set2)
# print(set2.difference(set1))                  # проверка на различие (вернёт отличия set2 по отношению к set1)
# print(set1.difference(set2))                  # проверка на различие (вернёт отличия set1 по отношению к set2)
# print(set1.symmetric_difference(set2))        # вернёт те значения, которых нет в set1 и set2 (не повторяются в обоих множествах)

# print(set1)
# print(id(set1))
#
# set1.remove(1)         # удалили 1
# print(set1)
# print(id(set1))
#
# set1.add(8)            # добавили 8
# print(set1)
# print(id(set1))        # id не меняется (изменяемая структура данных)


# fs = frozenset({1, 2, 3})   # метод frosenset позволяет не изменять множество
# print(fs)
# fs.remove(1)                # вернёт ошибку
# print(fs)


