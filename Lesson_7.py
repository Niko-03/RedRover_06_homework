'''     SELENIUM WEBDRIVER

- это программная библиотека для управления браузерами (короткое название webdriver);
- используется для UI-тестирования (для тестирования сайта с точки зрения пользователя);
- для начала работы с selenium webdriver необходимо определить три ключевых элемента:
                    - браузер,
                    - драйвер браузера,
                    - скрипт для драйвера браузера.


----------- Основные методы Selenium Webdriver ------------------------------------

- driver.current_url        ------------>  получить url-адрес текущей страницы
- driver.current_window_handle  -------->  получить дескриптор текущего окна (по индексу переключаемся на одно или другое окно (что это???))
- driver.name                ----------->  получить имя браузера внизу экземпляра
- driver.orientation         ----------->  получить местоположение текущего устройства
- driver.page_source         ----------->  получить исходный код текущей страницы
- driver.title               ----------->  получить заголовок текущей страницы
- driver.refresh()           ----------->  обновить текущую страницу
- driver.switch_to_alert()   ----------->  переключить фокус на предупреждение, которое появляется на текущей странице
- driver.switch_to_active_element()  --->  вернуть элемент с единственным фокусом текущей страницы
- driver.find.element()    ------------->  найти элемент по определенному локатору
- driver.maximize_window()  ------------>  открывает страницу сайта в полном размере
- driver.minimize_window()  ------------>
- element.send_keys()      ------------->  заполнить заданный элемент
- element.click()          ------------->  выполнить клик по указанному элементу
- driver.close()           ------------->  закрыть текущее окно браузера
- driver.quit()            ------------->  закрыть все окна, вкладки, и процессы вебдрайвера, запущенные во время тестовой сессии



(browser.close() закрывает текущее окно браузера. Это значит, что если ваш скрипт вызвал всплывающее окно,
 или открыл что-то в новом окне или вкладке браузера, то закроется только текущее окно, а все остальные останутся висеть.
 В свою очередь browser.quit() закрывает все окна, вкладки, и процессы вебдрайвера, запущенные во время тестовой сессии.)



---------------------- про ASSERT -----------------------------------------------------------------------

Инструкции assert в Python — это булевы выражения, которые проверяют, является ли условие истинным (True).
Они определяют факты (утверждения) в программе.
Assertion — это проверка, которую можно включить, а затем выключить, завершив тестирование программы.

(Ключевое слово assert сравнивает два значения и возвращает True, если они равны, и False — если нет.)



------------------ ОЖИДАНИЯ в Selenium ------------------------------------------------------------------
(посмотреть на сайте   selenium.dev/documentation/webdriver/waits/)

- не всегда test успевает кликнуть по элементу, бывает так, что необходимо доп.время для загрузки,
- или элемент появляется (или пропадает) на странице после определённых действий.
- Для этого используют ОЖИДАНИЯ.

- Explicit wait - импортируется <from selenium.webdriver.support.wait import WebDriverWait>

- Expected conditions (явные ожидания):
        - alert is present
        - element exists
        - element is visible
        - title contains
        - title is
        - element staleness
        - visible text

- Implicit wait (не явные ожидания):
        - driver.implicitly_wait(10)               # жди 10 секунд (например)  - более грамотная замена методу time.sleep

- FluentWait - кроме прочего принимает параметр <сколько раз проверить>   --> poll_frequency=1 (например)
             - или игнорирование каких-то ошибок                          -->   ignored_exceptions=[]



----------------------------------- PYTEST ------------------------------------------------------------------------

- это среда тестирования, основанная на Python, её используют для написания и выполнения тестового кода;
- выполнение определённого набора тестов с помощью фильтрации;
- параметризация тестов - запуск одного и того же теста с разными наборами параметров;
- полная обратная совместимость с UNITTEST - возможность запуска тестов, написанных на нём;
- выполнение нескольких тестов параллельно;
- отчёт с результатами выполнения тестов, цветной отчёт в консоли выглядит удобнее - красные FAILED видны сразу;
- удобный ASSERT (стандартный из Python), не надо запоминать разные ASSERT`ы, как например в UNITTEST.



------------------------------- про UNITTEST (справочно) -----------------------------------------------------------

Unittest - инструмент для тестирования в Python. Это стандартный модуль для написания юнит-тестов на Python.
Unittest это порт JUnit с Java. Иными словами, и в коде модуля, и при написании тестов легко прослеживается ООП стиль,
что весьма удобно для тестирования процедур и классов.


Модуль unittest предоставляет базовый класс TestCase, который можно использовать для создания новых тестовых случаев.
Набор тестов (test suite) - несколько тестовых случаев, наборов тестов или и того и другого. Он используется для объединения тестов,
которые должны быть выполнены вместе.
Исполнитель тестов (test runner) - компонент, который управляет выполнением тестов и предоставляет пользователю результат.
Исполнитель может использовать графический или текстовый интерфейс или возвращать специальное значение, которое сообщает о результатах выполнения тестов.
Модуль unittest предоставляет богатый набор инструментов для написания и запуска тестов.




-------------------------------- ФИКСТУРЫ (FIXTURES) -------------------------------------------------------------

- фикстуры в контексте pytest - это вспомогательные функции для тестов, они не являются частью тестового сценария;
- в pytest фикстуры можно задавать глобально, передавать их в тестовые методы, как параметры;
- pytest также имеет набор встроенных фикстур;
- фикстуры обеспечивают надёжность тестов, согласованность и повторяемость их результатов.
  При инициализации можно настраивать сервисы, состояния, переменные окружения;
- для фикстур можно задавать область покрытия (SCOPE). Например, "FUNCTION", "CLASS", "MODULE", "SESSION".
  Соответственно, фикстура будет вызываться один раз либо для тестового метода, либо для класса, модуля или сессии.

- фикстура задаётся файлом conftest.py в корне проекта.


------------------- ПРИМЕР ФИКСТУРЫ -----------------------------------------------
- сначала прописываем все импорты


@pytest.fixture(scope='function')                   # задаём декоратор, чтобы pytest распознавал функцию def driver(), как фикстуру
                                                    # в () определяем, на какой уровень распространяется фикстура

def driver():                                       # фикстура (как функция def driver() )
    print('start browser')
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))     # создали экземпляр выбранного драйвера (браузера) и установили драйвер в фикстуру
    driver.maximize_window()                        # полноэкранный режим отображения веб-страницы
    yield driver                                    # yield почти то же самое, что и retern (???)
    driver.quit()                                   # закрыть все окна, вкладки, и процессы вебдрайвера, запущенные во время тестовой сессии


- затем в основном файле (test.py) в наши функции добавляем в качестве параметра driver (название функции из фикстуры)

- если фикстура распространяется на уровень функций, то метод driver.get (открытие страницы сайта)
  прописываем в каждой функции нашего файла (test.py)    < @pytest.fixture(scope='function') >

- если фикстура распространяется на уровень сессии  < @pytest.fixture(scope='session') >
  то запуск веб-страницы будет только один раз, и тесты, прописанные в файле test.py, отработают с одним открытием окна.

- если в scope ничего не указано < @pytest.fixture() >, то по умолчанию < @pytest.fixture(scope='function') >





---------------------- PAGE OBJECT MODEL (POM) -------------------------------------------------------------------

- POM - это паттерн программирования, широко применяемый в атоматизации тестирования.
  Его основная идея состоит в том, что любую страницу веб-приложения можно представить в виде объекта класса.
  С этой точки зрения:
             - способы взаимодействия со страницей - это методы класса,
             - элементы веб-страницы - атрибуты класса.

- POM позволяет отделить код, относящийся к тестам, от кода, описывающего страницу (локаторы)
  и способы взаимодействия с ней (открыть страницу, авторизоваться, положить товар в корзину и т.д.).
  Поэтому, при изменении вёрстки страницы, нет необходимости переписывать тесты,
  надо лишь внести изменения в класс, который описывает эту страницу.


'''


