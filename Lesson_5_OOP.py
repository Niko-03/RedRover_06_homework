''' ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ (ООП)

- это подход, при котором программа рассматривается как набор объектов, взаимодействующих друг с другом;
- чтобы сделать код проще, программу разбивают на независимые блоки - объекты;
- в программировании объекты - это структуры данных: пользователь, кнопка, сообщение;
- у них (объектов) могут быть свойства: цвет, содержание, имя пользователя;
- классы - объединяют между собой объекты с похожими свойствами.

- КЛАСС - это шаблон кода, по которому создаются объекты, имеющие общую структуру
        и обладающие одинаковым поведением. Сам по себе класс ничего не делает,
        но с его помощью можно создать объект и использовать его в работе.

- ОБЪЕКТ - это экземпляр класса.

- АТРИБУТ объекта - это свойства объекта (собака большая).
- МЕТОДЫ - это поведение объекта (собака лает).

- СТАТИЧЕСКИЕ ПОЛЯ - они же переменные, или атрибуты класса - это переменные, которые объявляются внутри тела класса,
                     и создаются тогда, когда создаётся класс.

- ДИНАМИЧЕСКИЕ ПОЛЯ - переменные, или атрибуты экземпляра класса - это переменные, которые создаются
                      на уровне экземпляра класса.


---------- КОСТРУКТОР (метод __INIT__) -------------------

- в ООП конструктором класса называют метод, который автоматически вызывается при создании объектов.
  Его также можно назвать КОНСТРУКТОРОМ ОБЪЕКТОВ КЛАССА.

- метод __init__() - играет роль конструктора в Python
- параметр self - ссылка на только что созданный объект

- необходимость конструктора связана с тем, что часто объекты должны иметь собственные свойства сразу.


- синтаксис:          CLASS PERSON:
                         DEF __INIT__(SELF,NAME, SURNAME):
                            SELF.NAME = NAME
                            SELF.SURNAME = SURNAME

                      PERSON_1 = PERSON('ALEX', 'BAKER')  - при вызове класса в () передаются значения,
                                                            которые будут присвоены параметрам метода __init__()


-------------- НАСЛЕДОВАНИЕ -------------------------------------

- позволяет выделить общее для нескольких классов поведение, и вынести его в отдельную сущность.
  т.е. наследование является средством переиспользования кода
  (например внутри класса Dog можно создать класс Порода. И при этом наследование позволяет использовать код суперкласса (Dog))
- CODE REUSE - использование существующего кода для решения новых задач.



--------------- ИНКАПСУЛЯЦИЯ ---------------------------------------------

- методы и атрибуты инкапсулируются внутри одного класса
- инкапсуляцию можно рассматривать как группировку логически связанных данных и методов,
  и как механизм контроля доступа к данным (разные уровни доступа к атрибутам).


- Уровни доступа к атрибутам объекта - чтобы нельзя было напрямую менять значения атрибутов:
        - Public (self.color = 'Red')
        - Protected (self._color = 'Grey')  - это как негласное соглашение - когда у атрибута есть _ или __ , то меняем значения через set.
        - Private (self.__color = 'Orange')


- Менять значения атрибутов можно при помощи методов GET и SET.

- метод GET - возвращает значение по указанному ключу в параметрах.
- метод SET - для того, чтобы не было прямого доступа к атрибутам объекта.


-------------- ПОЛИМОРФИЗМ ------------------------------------------------

- разное поведение одного и того же метода в разных классах
- пример: есть класс Person, и дочерние подклассы Programmer, Dancer, Singer.
  Они все чему-то учаться - один метод на всех,
  но учаться разному - разное поведение одного метода.


-------------- АБСТРАКЦИЯ ----------------------------------------------

- выделение основнык, наиболее значимых, характиристик объекта
  и игнорировать второстепенных.
- пример: мне не обязательно знать, что внутри телефона, мне важен его функционал.



---------------------- про Git (система контроля версий - VCS)----------------------------------------

- консольная утилита для отслеживания и ведения истории изменения файлов.

- задачи, которые решает VCS:
        - защищает исходный код от потери
        - обеспечивает командную работу
        - обеспечивает распределённую работу
        - помогает отменить изменения


'''


class Dog:                                               # class - ключевое слово (создание шаблона)
    biology_class = 'Animal'                             # статический атрибут класса Dog, относится ко всем объектам класса

    def __init__(self, name, age, weight, color):             # метод __init__ создаёт динамические атрибуты (name, weight, color)
        self._name = name                                 # self (свойство) - ссылка на только что созданный объект
        self.age = age
        self.weight = weight
        self.__color = color
#
    def run(self):                                       # создали метод run (бегать) - (название метода придумываем сами)
        return 'I can run!'
# #
    def get_name(self):                                  # метод (get), который возвращает имя - (название метода придумываем сами)
        return f'Hello! My name is {self._name}.'         # так получим имя
#
    def set_name(self, new_name):                           # метод (set) изменяет значение атрибута
        self._name = new_name

    def get_info(self):                                    # метод вернёт информацию о экземпляре класса (название метода придумываем сами)
        print(f'Собака {self._name} {self.age} лет')

    def speak(self, sound):
        self.sound = sound
        print(f'Собака говорит {self.sound}')


dog1 = Dog('Bobik', 5, 12, 'brown')                         # создали объект класса Dog с указанием его атрибутов (аргументов)
print(dog1._name)                                        # так можно получить имя объекта
print(dog1.get_name())                                  # метод get_name выдаст имя с фразой
# print(dog1.color)
print(dog1.set_name('Sharik'))                          #  через set изменили значение атрибута _name
print(dog1.get_name())                                  # вызвали name после изменений
# print(dog1._name)                                       # или так можно вызвать _name
# print(dog1.__dict__)
# print(dog1._Dog__color)                                 # доступ к значению атрибута Private
dog1.get_info()                                         # метод get_info() вернёт информацию о экземпляре класса
dog1.speak('Гав')


# dog2 = Dog('Rex', 12, 'black')
# print(dog2.biology_class)                            # посмотреть значение статического метода
# print(dog2.get_name())
# print(dog2.__dict__)                                 # спрсоб посмотреть на атрибуты объекта (словарь)
# dog2.name = 'Snoopy'                                 # изменили значение атрибута
# print(dog2.get_name())                               # метод get
# print(dog2.__dict__)                                 # с изменённым значением


class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def get_info(self):
        print(f'Кошке {self.name} {self.age} лет')

    def speak(self, sound):
        self.sound = sound
        print(f'Кошка говорит {self.sound}')


cat1 = Cat('Ксюша', 3)
cat1.get_info()
cat1.speak('Мяу')










# -------------- НАСЛЕДОВАНИЕ -----------------------


# class Pitbull(Dog):                                       # класс-наследник, в скобках класс-родитель
#     def __init__(self, name, weight, color, passport):    # конструктор с атрибутами
#         super().__init__(name, weight, color)             # метод super() - ссылка на атрибуты родительского класса
#         self.passport = passport                          # новый атрибут только для класса Pitbull
#
#
#     def give_a_paw(self):                                 # новый метод для класса Pitbull
#         return 'I can give a paw))'
#
#
#     def run(self):
#         return 'I can run fast!'                         # пример полиморфизма


# dog3 = Pitbull('Lassie', 8, 'black', 'type1')              # объект класса Pitbull
# print(dog3.get_name())                                     # статический атрибут родительского класса (Dog)
# print(dog3.biology_class)
# print(dog3.give_a_paw())
# print(dog3.passport)
# # print(dog2.passport)                 # будет ошибка (инкапсуляция), у объекта dog2 нет атрибута passport
# # print(dog2.give_a_paw())               # будет ошибка (инкапсуляция) - то же самое, что и с паспортом
# print(dog2.run())                        # пример проявления
# print(dog3.run())                        # полиморфизма





















